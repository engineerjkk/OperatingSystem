# 컴퓨터에서의 플랫폼 : Operating System
## 운영체제의 역사
* 다른 응용프로그램이 실행될 수 있는 환경을 제공
* A program that controls the execution of application programs
* An interface between applications and hardware

* Main objectives of an OS : 운영체제가 추구하는 목적
- convenience : 편리성
- efficiency : CPU, memory
- ability to evolve : 추가적인 하드웨어를 받을 수 있는 확장성, 새로운 환경에 진화

- 1970년 중반부터 PC가 등장한다. 그 이전의 중대형 컴퓨터였다.
중대형 컴퓨터는 잘 아는사람이 썼지만 PC는 잘 몰라도 작업하기 위해서 사용한다. 내부동작원리를 잘 이해하게 하고 쓴다면 사람들이 편리하게 쓰기 어렵다.
-> 따라서 보다 사람들이 쉽게 사용하는 것이 중요한것이 운영체제의 목적이었다.  

![image](https://user-images.githubusercontent.com/76835313/132607984-891ce910-4c85-424a-9992-cc044f7d9eca.png)
1. CPU는 Execution hardware에 있으며, 프로그램들은 Main memory에 적재된다.
2. 이러한 CPU과 프로그램들은 bus를 통해서 연결되어있게 된다.
3. Instruction Set Architecture 아래서 하드웨어 구성이며 이 하드웨어를 제대로 동작하게 하는 것이 Operating System의 역할이 된다.
4. 즉, 하드웨어를 구동시켜주고 다른 Application이 실행할 수 있도록, 라이브러리, 유틸리티를 제공한다.   

         The hardware and software used in providing applications to a user can be viewed
         in a layered or hierarchical fashion, as depicted in Figure 2.1 . The user of those
         applications, the end user, generally is not concerned with the details of computer
         hardware. Thus, the end user views a computer system in terms of a set of applications.
         An application can be expressed in a programming language and is developed
         by an application programmer. If one were to develop an application program as a
         set of machine instructions that is completely responsible for controlling the computer
         hardware, one would be faced with an overwhelmingly complex undertaking.
         To ease this chore, a set of system programs is provided. Some of these programs
         are referred to as utilities, or library programs. These implement frequently used
         functions that assist in program creation, the management of files, and the control of
         I/O devices. A programmer will make use of these facilities in developing an application,
         and the application, while it is running, will invoke the utilities to perform
         certain functions. The most important collection of system programs comprises the
         OS. The OS masks the details of the hardware from the programmer and provides
         the programmer with a convenient interface for using the system. It acts as mediator,
         making it easier for the programmer and for application programs to access and
         use those facilities and services.


![image](https://user-images.githubusercontent.com/76835313/132608558-21a847d5-626a-4c60-8b2d-0ab322ab41da.png)

API : 응용프로그램에서는 하부 계층에 있는 라이브러리의 기능들을 호출함으로써 하드웨어적 기능을 활용한다.
-> UNIX에서는 System Call이라고 부른다.   
![image](https://user-images.githubusercontent.com/76835313/132608580-3adb1741-61c1-4cb9-91b3-c6663e5b4c67.png)
1. 프로그램을 실행 시켜주어야한다.
2. I/O 디바이스를 접근하게 해준다.
3. 운영체제에 의해서 파일들을 관리한다
4. 시스템의 자원 : CPU, Memory
5. 프로그램 개발환경 지원
6. 에러가 날 경우 중단시킨다. 
7. 회계 -> 개인으로 쓰는건 이런 개념이 없지만 서버들은 얼마만큼의 CPU를 얼마동안 썼는지, 메모리 얼마썼는지 비용을 계산해 청구한다.  

![image](https://user-images.githubusercontent.com/76835313/132608721-15ae8d0e-b9b1-4b5d-a98f-59f02070deb1.png)
* 데이터를 옮기로 처리하기 위한 자원들의 집합
* 리소스들을 관리한다. 

![image](https://user-images.githubusercontent.com/76835313/132608830-dc516cf6-a6f5-4e47-8531-d7c717658deb.png)
1. 운영체제는 기본적으로 소프트웨어이다. 프로그램이 동작하는 것과 똑같이 동작한다. 
2. 프로그램들의 집합이며, 결국 CPU에서 실행되어야만 프로그램을 컴퓨터에서 제공할 수 있다. 
3. 운영체제가 다시 CPU에서 실행되려하면 CPU에 의해서 이루어진다. 운영체제의 기능은 CPU에서 실행될때 기능하고 필요없으면 제어를 포기하고 다른 응용프로그램들이 CPU에서 실행 될 수 있도록한다. 

![image](https://user-images.githubusercontent.com/76835313/132609011-5d918bc0-9fe0-4c22-926f-e25f7612743f.png)  
![image](https://user-images.githubusercontent.com/76835313/132609132-c506f077-cc6c-433c-97b9-8be8aac0cd78.png)
1. 대부분의 중요한 운영체제는 시간에 따라서 진화해 왔다.
2. 새로운 서비스를 제공해야 운영체제가 살아남는다. -> 적자생존

![image](https://user-images.githubusercontent.com/76835313/132609515-71dd78f7-4f90-4579-99b0-4d22a1fbafcf.png)
1. 처음엔 순차적으로 처리했다.
2. CPU, memory를 효율적으로 사용하기 위해 Simple Batch Systems
3. Multiprogrammed Batch Systems
4. Time Sharing Systems -> Clinets의 요청을 받기 위해

![image](https://user-images.githubusercontent.com/76835313/132609636-3bbb752a-5bcf-4460-8dac-9fb414aade4a.png)  
1. 처음에는 운영체제가 없었다. 사용자가 직접 하드웨어를 조작하여 실행시켰다. 
2. 컴퓨터에 직접 연결돼있는것 : 콘솔  
-> display lights, switches, keyboard, printer로 이루어져있었고 이거를 실행시켰다.   
3. 차례로 컴퓨터에 접근할 수 있었다. 

하지만 이로인한 문제는 사용자들이 컴퓨터를 사용하기 위해 얼마나 컴퓨터를 사용할지 신청서에다가 사인해서 제출해야 했다.   
![image](https://user-images.githubusercontent.com/76835313/132610822-d1066124-df74-43b1-a350-5b883fae7179.png)  
 
![image](https://user-images.githubusercontent.com/76835313/132611849-4fe3e347-e7b6-4af5-b596-af3597c5ecb7.png)  
  
1. resident는 상주한다는 뜻이된다. 거주민을 resident. 의사로서 레지던트는 수련이기에 병원에서 상주한다.  
  
![image](https://user-images.githubusercontent.com/76835313/132612325-2bb6128e-7f8f-4844-b1f5-ac5834bbf958.png)  
1. 메모리에 있는 명령어를 실행한다. 응용프로그램의 코드. 운영체제의 기능.  
2. CPU가 user 프로그램을 실행하는데 언제까지 실행하냐 -> } 를 만날 때 까지 or return을 만날때까지하면 운영체제 종료할 때 까지 한다.   
3. CPU가 실행되는 권한을 모니터에게 되돌려준다.   

![image](https://user-images.githubusercontent.com/76835313/132612498-6aa0c0a6-7de1-44cf-af04-340b90a270cd.png)  
![image](https://user-images.githubusercontent.com/76835313/132612909-7ebd2d7f-db9a-44e8-9174-2f478c3e97b6.png)  
![image](https://user-images.githubusercontent.com/76835313/132612980-f429a5fa-c605-4c8b-8a8d-880223f1a1a7.png)  
잡 스탭은 잡 컨트롤    
![image](https://user-images.githubusercontent.com/76835313/132613037-5062dfd9-9aad-44b5-bd45-923e42836770.png)
1.Memory
2. Timer
3. 특별한 목적으로 만들어진 기계어
4. Interrupts : 여러개의 응용프로그램이 실행되더라고 급한걸 먼저처리함으로써 전체적으로 조화롭게 대처하면서 실행시키는 것이다. ![image](https://user-images.githubusercontent.com/76835313/132613381-9ccb8a19-e20d-4020-abb3-2a47b83c9354.png)

![image](https://user-images.githubusercontent.com/76835313/132613383-296a21ce-75ac-4715-8dbc-a5a74cb13d19.png)
1. 유저모드
2. 커널모드
-> 운영체제는 모드를 통해 안전하게 관리한다.
-> 유저모드에서 할당된 영역은 유저의 access에서 보호가 된다. 다른 사용자들은 그 메모리 영역을 접근하면 안된다.
-> 커널모드에서는 모니터가 실행되는건 커널모드에서 실행된다. 그 다음에 사용자의 메모리영역이라하더라도 때에따라 접근할 수 있어.

![image](https://user-images.githubusercontent.com/76835313/132613578-77ccab92-4da8-440a-ba8c-5b45174687a7.png)

![image](https://user-images.githubusercontent.com/76835313/132613698-034845ae-59ac-4bac-b38a-ff84226ce358.png)
file에서 하나의 recode를 읽는데 15us가 걸렸다. 100개 메모리는 1us이다. 그러면 이 작업을 하나의 프로그램이 했다면 전체적으로 31us이다. 
CPU는 종종 놀고있다. 입출력은 메모리단에 비해면 메우 느리다.

![image](https://user-images.githubusercontent.com/76835313/132613870-9fc320b0-44c6-4ce7-93a2-7c28b07156c7.png)
* 순차적으로 실행되는것 uni 프로그램이다.
![image](https://user-images.githubusercontent.com/76835313/132613909-275feb01-3330-4fd8-a292-429f46954638.png)
* 그래서 멀티프로그래밍을 도입한다.  
![image](https://user-images.githubusercontent.com/76835313/132613969-f1034b57-07f2-435e-97fe-2681626af46d.png)
![image](https://user-images.githubusercontent.com/76835313/132614030-5f262381-b612-4ef0-bd7a-f6ad6abc62ad.png)
![image](https://user-images.githubusercontent.com/76835313/132614138-997ede3b-0e22-4b42-a120-13a206882ad3.png)
![image](https://user-images.githubusercontent.com/76835313/132614419-fe3318d5-16f7-418b-8a43-bf6167b6fada.png)
![image](https://user-images.githubusercontent.com/76835313/132614702-8d82ad1a-4363-4d1d-805e-224fd75ca112.png)
* Time sharing System으로 발전했다. 
* 여기서 Time은 CPU시간을 의미한다. 
* interactive jobs. 상호작용. 그거보고 실행하며 되돌려받으며 컴퓨터를 사용한다. 
* CPU가 조금식 나눠쓰며 공유한다.
![image](https://user-images.githubusercontent.com/76835313/132614960-9d511d50-cd08-4081-bb6e-ebc86b578ae6.png)
* 응답시간을 최소화하는 것이 목적이다. 컴퓨터의 자원이 아주 충분히 잘 발전했기에 사용자가 더 편리하게, 지연되지않는것을 목적으로한다. 
![image](https://user-images.githubusercontent.com/76835313/132615080-4a5fde6d-32f9-4868-b403-c92d377699a6.png)
* CTSS 
* Time Slicing : 시분할 시스템
-> 시스템의 클럭을 통해서한다. 
![image](https://user-images.githubusercontent.com/76835313/132615166-9730b2cb-5fdd-4adb-ac41-3c933288a78d.png)
![image](https://user-images.githubusercontent.com/76835313/132615231-c892289b-4ca2-4ffb-aa3d-339633d282d9.png)
* 운영체제는 수많은 프로그램들을 실행시켜주는 소프트웨어기때문에 복잡한 소프트웨어이다. 
* 이때 주요한 개념이 프로세스, 메모리관리, 메모리보호, CPU와 disk의 스케줄링, 자원관리 등을 관리하기위해 발전해왔다.
![image](https://user-images.githubusercontent.com/76835313/132615311-c68440ae-12c3-48ec-bc3b-54f60aa6e8d0.png)
-> 프로그램을 실행시키면 프로세스가 된다. 운영체제는 프로세스를 관리한다. 
![image](https://user-images.githubusercontent.com/76835313/132615378-b793a034-a046-4c1e-9d68-e88c39c10ce5.png)
프로세스의 발전 : 멀티프로그래밍 배치, time sharing, real-time

          Three major lines of computer system development created problems in timing
          and synchronization that contributed to the development of the concept of the
          process: multiprogramming batch operation, time sharing, and real-time transaction
          systems. As we have seen, multiprogramming was designed to keep the processor
          and I/O devices, including storage devices, simultaneously busy to achieve maximum
          efficiency. The key mechanism is this: In response to signals indicating the
          completion of I/O transactions, the processor is switched among the various programs
          residing in main memory.

          A second line of development was general-purpose time sharing. Here, the
          key design objective is to be responsive to the needs of the individual user and yet,
          for cost reasons, be able to support many users simultaneously. These goals are
          compatible because of the relatively slow reaction time of the user. For example,
          if a typical user needs an average of 2 seconds of processing time per minute, then
          close to 30 such users should be able to share the same system without noticeable
          interference. Of course, OS overhead must be factored into such calculations.

          A third important line of development has been real-time transaction processing
          systems. In this case, a number of users are entering queries or updates against a
          database. An example is an airline reservation system. The key difference between
          the transaction processing system and the time-sharing system is that the former
          is limited to one or a few applications, whereas users of a time-sharing system can
          engage in program development, job execution, and the use of various applications.
          In both cases, system response time is paramount.



















