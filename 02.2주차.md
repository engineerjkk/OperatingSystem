# 컴퓨터에서의 플랫폼 : Operating System
## 운영체제의 역사
* 다른 응용프로그램이 실행될 수 있는 환경을 제공
* A program that controls the execution of application programs
* An interface between applications and hardware

* Main objectives of an OS : 운영체제가 추구하는 목적
- convenience : 편리성
- efficiency : CPU, memory
- ability to evolve : 추가적인 하드웨어를 받을 수 있는 확장성, 새로운 환경에 진화

- 1970년 중반부터 PC가 등장한다. 그 이전의 중대형 컴퓨터였다.
중대형 컴퓨터는 잘 아는사람이 썼지만 PC는 잘 몰라도 작업하기 위해서 사용한다. 내부동작원리를 잘 이해하게 하고 쓴다면 사람들이 편리하게 쓰기 어렵다.
-> 따라서 보다 사람들이 쉽게 사용하는 것이 중요한것이 운영체제의 목적이었다.  

![image](https://user-images.githubusercontent.com/76835313/132607984-891ce910-4c85-424a-9992-cc044f7d9eca.png)
1. CPU는 Execution hardware에 있으며, 프로그램들은 Main memory에 적재된다.
2. 이러한 CPU과 프로그램들은 bus를 통해서 연결되어있게 된다.
3. Instruction Set Architecture 아래서 하드웨어 구성이며 이 하드웨어를 제대로 동작하게 하는 것이 Operating System의 역할이 된다.
4. 즉, 하드웨어를 구동시켜주고 다른 Application이 실행할 수 있도록, 라이브러리, 유틸리티를 제공한다.   
![image](https://user-images.githubusercontent.com/76835313/132608558-21a847d5-626a-4c60-8b2d-0ab322ab41da.png)

API : 응용프로그램에서는 하부 계층에 있는 라이브러리의 기능들을 호출함으로써 하드웨어적 기능을 활용한다.
-> UNIX에서는 System Call이라고 부른다.   
![image](https://user-images.githubusercontent.com/76835313/132608580-3adb1741-61c1-4cb9-91b3-c6663e5b4c67.png)
1. 프로그램을 실행 시켜주어야한다.
2. I/O 디바이스를 접근하게 해준다.
3. 운영체제에 의해서 파일들을 관리한다
4. 시스템의 자원 : CPU, Memory
5. 프로그램 개발환경 지원
6. 에러가 날 경우 중단시킨다. 
7. 회계 -> 개인으로 쓰는건 이런 개념이 없지만 서버들은 얼마만큼의 CPU를 얼마동안 썼는지, 메모리 얼마썼는지 비용을 계산해 청구한다.  

![image](https://user-images.githubusercontent.com/76835313/132608721-15ae8d0e-b9b1-4b5d-a98f-59f02070deb1.png)
* 데이터를 옮기로 처리하기 위한 자원들의 집합
* 리소스들을 관리한다. 

![image](https://user-images.githubusercontent.com/76835313/132608830-dc516cf6-a6f5-4e47-8531-d7c717658deb.png)
1. 운영체제는 기본적으로 소프트웨어이다. 프로그램이 동작하는 것과 똑같이 동작한다. 
2. 프로그램들의 집합이며, 결국 CPU에서 실행되어야만 프로그램을 컴퓨터에서 제공할 수 있다. 
3. 운영체제가 다시 CPU에서 실행되려하면 CPU에 의해서 이루어진다. 운영체제의 기능은 CPU에서 실행될때 기능하고 필요없으면 제어를 포기하고 다른 응용프로그램들이 CPU에서 실행 될 수 있도록한다. 

![image](https://user-images.githubusercontent.com/76835313/132609011-5d918bc0-9fe0-4c22-926f-e25f7612743f.png)  
![image](https://user-images.githubusercontent.com/76835313/132609132-c506f077-cc6c-433c-97b9-8be8aac0cd78.png)
1. 대부분의 중요한 운영체제는 시간에 따라서 진화해 왔다.
2. 새로운 서비스를 제공해야 운영체제가 살아남는다. -> 적자생존

![image](https://user-images.githubusercontent.com/76835313/132609515-71dd78f7-4f90-4579-99b0-4d22a1fbafcf.png)
1. 처음엔 순차적으로 처리했다.
2. CPU, memory를 효율적으로 사용하기 위해 Simple Batch Systems
3. Multiprogrammed Batch Systems
4. Time Sharing Systems -> Clinets의 요청을 받기 위해

![image](https://user-images.githubusercontent.com/76835313/132609636-3bbb752a-5bcf-4460-8dac-9fb414aade4a.png)
1. 처음에는 운영체제가 없었다. 사용자가 직접 하드웨어를 조작하여 실행시켰다.
2. 컴퓨터에 직접 연결돼있는것 : 콘솔
-> display lights, switches, keyboard, printer로 이루어져있었고 이거를 실행시켰다.
3. 차례로 컴퓨터에 접근할 수 있었다.

하지만 이로인한 문제는 사용자들이 컴퓨터를 사용하기 위해 얼마나 컴퓨터를 사용할지 신청서에다가 사인해서 제출해야 했다. 
![image](https://user-images.githubusercontent.com/76835313/132610822-d1066124-df74-43b1-a350-5b883fae7179.png)

![image](https://user-images.githubusercontent.com/76835313/132611849-4fe3e347-e7b6-4af5-b596-af3597c5ecb7.png)

1. resident는 상주한다는 뜻이된다. 거주민을 resident. 의사로서 레지던트는 수련이기에 병원에서 상주한다.

![image](https://user-images.githubusercontent.com/76835313/132612325-2bb6128e-7f8f-4844-b1f5-ac5834bbf958.png)
1. 메모리에 있는 명령어를 실행한다. 응용프로그램의 코드. 운영체제의 기능.
2. CPU가 user 프로그램을 실행하는데 언제까지 실행하냐 -> } 를 만날 때 까지 or return을 만날때까지하면 운영체제 종료할 때 까지 한다. 
3. CPU가 실행되는 권한을 모니터에게 되돌려준다. 

![image](https://user-images.githubusercontent.com/76835313/132612498-6aa0c0a6-7de1-44cf-af04-340b90a270cd.png)
![image](https://user-images.githubusercontent.com/76835313/132612909-7ebd2d7f-db9a-44e8-9174-2f478c3e97b6.png)
![image](https://user-images.githubusercontent.com/76835313/132612980-f429a5fa-c605-4c8b-8a8d-880223f1a1a7.png)
잡 스탭은 잡 컨트롤
![image](https://user-images.githubusercontent.com/76835313/132613037-5062dfd9-9aad-44b5-bd45-923e42836770.png)
1.Memory
2. Timer
3. 특별한 목적으로 만들어진 기계어
4. Interrupts : 여러개의 응용프로그램이 실행되더라고 급한걸 먼저처리함으로써 전체적으로 조화롭게 대처하면서 실행시키는 것이다. ![image](https://user-images.githubusercontent.com/76835313/132613381-9ccb8a19-e20d-4020-abb3-2a47b83c9354.png)

![image](https://user-images.githubusercontent.com/76835313/132613383-296a21ce-75ac-4715-8dbc-a5a74cb13d19.png)
1. 유저모드
2. 커널모드
-> 운영체제는 모드를 통해 안전하게 관리한다.
-> 유저모드에서 할당된 영역은 유저의 access에서 보호가 된다. 다른 사용자들은 그 메모리 영역을 접근하면 안된다.
-> 커널모드에서는 모니터가 실행되는건 커널모드에서 실행된다. 그 다음에 사용자의 메모리영역이라하더라도 때에따라 접근할 수 있어.

![image](https://user-images.githubusercontent.com/76835313/132613578-77ccab92-4da8-440a-ba8c-5b45174687a7.png)





















